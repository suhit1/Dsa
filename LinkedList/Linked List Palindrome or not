// Problem link :- https://leetcode.com/problems/palindrome-linked-list/

// Brute

traverse the whole linkedlist and keep on storing the list into a string
later on traverse and check this string is palindrome or not

// optimal

class Solution {
    public boolean isPalindrome(ListNode head) {

        // if list is null will not be a palindrome
        if(head == null) return false;
        // if the list will be a single element only then it wil be a palindrome
        if(head.next == null) return true;

        // will  take a slow & fast Pointer
        ListNode slow =head;
        ListNode fast = head.next;

        while(fast!=null && fast.next!=null){
            slow = slow.next;
            fast = fast.next.next;
        }

        // will link the current slow pointer's element with the reversed list
        slow.next = reverseLinkedList(slow.next);
        slow = slow.next;

        // will take a dummy node from start
        ListNode dummy = head;

        // will now run a loop till slow pointer reaches null
        while(slow!=null){
            // if any element will not be equal from start position it means its not a palindrome linkedlist
            if(slow.val != dummy.val) return false;
            slow = slow.next;
            dummy = dummy.next;
        }
       return true;
    }

    public ListNode reverseLinkedList(ListNode head){
        ListNode prev =null;
        while(head!=null){
            ListNode temp = head.next;
            head.next = prev;
            prev = head;
            head = temp;
        }
        return prev;
    }
}